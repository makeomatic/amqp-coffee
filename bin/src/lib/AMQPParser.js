// Generated by CoffeeScript 1.10.0
(function() {
  var AMQPParser, EventEmitter, FrameType, Indicators, classes, debug, methodTable, methods, parseFields, parseIntFromBuffer, ref, ref1, ref2,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  ref = require('./config').constants, Indicators = ref.Indicators, FrameType = ref.FrameType;

  ref1 = require('./config').protocol, methodTable = ref1.methodTable, classes = ref1.classes, methods = ref1.methods;

  debug = require('./config').debug('amqp:AMQPParser');

  ref2 = require('./parseHelpers'), parseIntFromBuffer = ref2.parseIntFromBuffer, parseFields = ref2.parseFields;

  AMQPParser = (function(superClass) {
    extend(AMQPParser, superClass);

    function AMQPParser(version, type, connection) {
      this.connection = connection;
      connection.write("AMQP" + String.fromCharCode(0, 0, 9, 1));
      this.frameHeader = new Buffer(7);
      this.frameHeader.used = 0;
      this.frameHeader.length = this.frameHeader.length;
      this.parser = this.header;
    }

    AMQPParser.prototype.execute = function(data) {
      return this.parser = this.parser(data);
    };

    AMQPParser.prototype.header = function(data) {
      var dataLength, neededForCompleteHeader;
      dataLength = data.length;
      neededForCompleteHeader = this.frameHeader.length - this.frameHeader.used;
      data.copy(this.frameHeader, this.frameHeader.used, 0, dataLength);
      this.frameHeader.used += dataLength;
      if (this.frameHeader.used >= this.frameHeader.length) {
        this.frameHeader.read = 0;
        this.frameType = this.frameHeader[this.frameHeader.read++];
        this.frameChannel = parseIntFromBuffer(this.frameHeader, 2);
        this.frameSize = parseIntFromBuffer(this.frameHeader, 4);
        if (this.frameSize > this.connection.frameMax) {
          return this.error("Oversize frame " + this.frameSize);
        }
        this.frameBuffer = new Buffer(this.frameSize);
        this.frameBuffer.used = 0;
        this.frameHeader.used = 0;
        return this.frame(data.slice(neededForCompleteHeader));
      } else {
        return this.header;
      }
    };

    AMQPParser.prototype.frame = function(data) {
      var dataLength, neededForCompleteFrame;
      dataLength = data.length;
      neededForCompleteFrame = this.frameBuffer.length - this.frameBuffer.used;
      data.copy(this.frameBuffer, this.frameBuffer.used, 0, dataLength);
      this.frameBuffer.used += dataLength;
      if (dataLength > neededForCompleteFrame) {
        return this.frameEnd(data.slice(neededForCompleteFrame));
      } else if (dataLength === neededForCompleteFrame) {
        return this.frameEnd;
      } else {
        return this.frame;
      }
    };

    AMQPParser.prototype.frameEnd = function(data) {
      if (!(data.length > 0)) {
        return this.frameEnd;
      }
      if (data[0] !== Indicators.FRAME_END) {
        return this.error("Missing frame end marker");
      }
      switch (this.frameType) {
        case FrameType.METHOD:
          this.parseMethodFrame(this.frameChannel, this.frameBuffer);
          break;
        case FrameType.HEADER:
          this.parseHeaderFrame(this.frameChannel, this.frameBuffer);
          break;
        case FrameType.BODY:
          this.parseContent(this.frameChannel, this.frameBuffer);
          break;
        case FrameType.HEARTBEAT:
          this.emit('heartbeat');
          break;
        default:
          this.error("Unknown frametype " + this.frameType);
      }
      return this.header(data.slice(1));
    };

    AMQPParser.prototype.parseMethodFrame = function(channel, buffer) {
      var args, classId, method, methodId;
      buffer.read = 0;
      classId = parseIntFromBuffer(buffer, 2);
      methodId = parseIntFromBuffer(buffer, 2);
      if ((methodTable[classId] == null) || (methodTable[classId][methodId] == null)) {
        return this.error("bad classId, methodId pair: " + classId + ", " + methodId);
      }
      method = methodTable[classId][methodId];
      args = parseFields(buffer, method.fields);
      debug(3, function() {
        return channel + " > method " + method.name + " " + (JSON.stringify(args));
      });
      return this.emit('method', channel, method, args);
    };

    AMQPParser.prototype.parseHeaderFrame = function(channel, buffer) {
      var classIndex, classInfo, field, fields, i, j, len, properties, propertyFlags, ref3, size, weight;
      buffer.read = 0;
      classIndex = parseIntFromBuffer(buffer, 2);
      weight = parseIntFromBuffer(buffer, 2);
      size = parseIntFromBuffer(buffer, 8);
      classInfo = classes[classIndex];
      propertyFlags = parseIntFromBuffer(buffer, 2);
      fields = [];
      ref3 = classInfo.fields;
      for (i = j = 0, len = ref3.length; j < len; i = ++j) {
        field = ref3[i];
        if ((i + 1) % 15 === 0) {
          parseIntFromBuffer(buffer, 2);
        }
        if (propertyFlags & (1 << (15 - (i % 15)))) {
          fields.push(field);
        }
      }
      properties = parseFields(buffer, fields);
      debug(3, function() {
        return channel + " > contentHeader " + (JSON.stringify(properties)) + " " + size;
      });
      return this.emit('contentHeader', channel, classInfo, weight, properties, size);
    };

    AMQPParser.prototype.parseContent = function(channel, data) {
      debug(3, function() {
        return channel + " > content " + data.length;
      });
      return this.emit('content', channel, data);
    };

    AMQPParser.prototype.error = function(error) {
      debug("Parser error " + error);
      this.emit('error', error);
      this.frameHeader.used = 0;
      return this.header;
    };

    return AMQPParser;

  })(EventEmitter);

  module.exports = AMQPParser;

}).call(this);

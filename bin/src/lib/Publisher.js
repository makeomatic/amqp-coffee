// Generated by CoffeeScript 1.10.0
(function() {
  var BSON, Channel, Publisher, _, bson, classes, debug, defaults, methodTable, methods, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  debug = require('./config').debug('amqp:Publisher');

  Channel = require('./Channel');

  defaults = require('./defaults');

  _ = require('underscore');

  bson = require('bson');

  BSON = new bson.BSONPure.BSON();

  ref = require('./config').protocol, methodTable = ref.methodTable, classes = ref.classes, methods = ref.methods;

  Publisher = (function(superClass) {
    extend(Publisher, superClass);

    function Publisher(connection, channel, confirm) {
      this._channelClosed = bind(this._channelClosed, this);
      this.confirmMode = bind(this.confirmMode, this);
      Publisher.__super__.constructor.call(this, connection, channel);
      this.seqCallbacks = {};
      this.confirm = confirm != null ? confirm : false;
      this.currentMethod = null;
      this.currentArgs = null;
      if (this.confirm) {
        this.confirmMode();
      }
      return this;
    }

    Publisher.prototype.confirmMode = function(cb) {
      this.confirmState = 'opening';
      return this.taskPush(methods.confirmSelect, {
        noWait: false
      }, methods.confirmSelectOk, (function(_this) {
        return function() {
          _this.confirmState = 'open';
          _this.confirm = true;
          _this.seq = 1;
          if (cb != null) {
            cb();
          }
          return _this.emit('confirm');
        };
      })(this));
    };

    Publisher.prototype._channelClosed = function(message) {
      var cb, key, ref1;
      this.confirmState = 'closed';
      if (message == null) {
        message = "Channel closed, try again";
      }
      ref1 = this.seqCallbacks;
      for (key in ref1) {
        cb = ref1[key];
        if (typeof cb === 'function') {
          cb(message);
        }
      }
      this.seqCallbacks = {};
      if (this.confirm) {
        return this.confirmMode();
      }
    };

    Publisher.prototype.publish = function(exchange, routingKey, data, options, cb) {
      var thisSequenceNumber, waitFor;
      if (typeof options === 'function') {
        cb = options;
        options = {};
      }
      if (options == null) {
        options = {};
      } else {
        options = _.clone(options);
      }
      if (this.state !== "open" || (this.confirm && this.confirmState !== "open")) {
        if (this.state === "opening" || this.state === "closed" || (this.confirm && this.confirmState === 'opening')) {
          if (this.confirm) {
            waitFor = 'confirm';
          } else {
            waitFor = 'open';
          }
          return this.once(waitFor, (function(_this) {
            return function() {
              return _this.publish(exchange, routingKey, data, options, cb);
            };
          })(this));
        } else {
          if (cb) {
            return cb("Channel is closed and will not re-open? " + this.state + " " + this.confirm + " " + this.confirmState);
          }
        }
      }
      if (typeof data === 'string') {
        options.contentType = 'string/utf8';
        data = new Buffer(data, 'utf8');
      } else if (typeof data === 'object' && !(data instanceof Buffer)) {
        if (options.contentType != null) {
          debug(1, (function(_this) {
            return function() {
              return "contentType specified but data isn't a buffer, " + (JSON.stringify(options));
            };
          })(this));
          if (cb != null) {
            cb("contentType specified but data isn't a buffer");
            return;
          }
        }
        data = new Buffer(JSON.stringify(data), 'utf8');
        options.contentType = 'application/json';
      }
      if (this.confirm) {
        thisSequenceNumber = this.seq++;
      }
      options = _.defaults(options, defaults.basicPublish);
      options.exchange = exchange;
      options.routingKey = routingKey;
      if (this.confirm && (cb != null) && (options.mandatory || options.immediate)) {
        if (options.headers == null) {
          options.headers = {};
        }
        options.headers['x-seq'] = thisSequenceNumber;
      }
      this.queuePublish(methods.basicPublish, data, options);
      if (this.confirm && (cb != null)) {
        debug(4, (function(_this) {
          return function() {
            return JSON.stringify({
              exchange: exchange,
              routingKey: routingKey,
              data: data,
              options: options,
              thisSequenceNumber: thisSequenceNumber
            });
          };
        })(this));
        return this._waitForSeq(thisSequenceNumber, cb);
      } else {
        debug(4, (function(_this) {
          return function() {
            return JSON.stringify({
              exchange: exchange,
              routingKey: routingKey,
              data: data,
              options: options,
              noConfirm: true
            });
          };
        })(this));
        if (cb != null) {
          return _.defer(cb);
        }
      }
    };

    Publisher.prototype._onMethod = function(channel, method, args) {
      this.currentMethod = method;
      this.currentArgs = args;
      switch (method) {
        case methods.basicAck:
          if (this.confirm) {
            return this._gotSeq(args.deliveryTag, args.multiple);
          }
      }
    };

    Publisher.prototype._onContentHeader = function(channel, classInfo, weight, properties, size) {
      var ref1;
      switch (this.currentMethod) {
        case methods.basicReturn:
          if (((ref1 = properties.headers) != null ? ref1['x-seq'] : void 0) != null) {
            return this._gotSeq(properties.headers['x-seq'], false, this.currentArgs);
          }
      }
    };

    Publisher.prototype._onContent = function(channel, data) {};

    Publisher.prototype._waitForSeq = function(seq, cb) {
      if (typeof cb === 'function') {
        return this.seqCallbacks[seq] = cb;
      } else {
        debug("callback requested for publish that isn't a function");
        return console.error(cb);
      }
    };

    Publisher.prototype._gotSeq = function(seq, multi, err) {
      var i, key, keys, len, results;
      if (err == null) {
        err = null;
      }
      if (multi) {
        keys = _.keys(this.seqCallbacks);
        results = [];
        for (i = 0, len = keys.length; i < len; i++) {
          key = keys[i];
          if (key <= seq) {
            this.seqCallbacks[key](err);
            results.push(delete this.seqCallbacks[key]);
          } else {
            results.push(void 0);
          }
        }
        return results;
      } else {
        if (this.seqCallbacks[seq] != null) {
          this.seqCallbacks[seq](err);
        } else {
          debug(3, function() {
            return "got a seq for " + seq + " but that callback either doesn't exist or was already called or was returned";
          });
        }
        return delete this.seqCallbacks[seq];
      }
    };

    return Publisher;

  })(Channel);

  module.exports = Publisher;

}).call(this);

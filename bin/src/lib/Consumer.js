// Generated by CoffeeScript 1.10.0
(function() {
  var BSON, CONSUMER_STATES_CLOSED, CONSUMER_STATE_CHANNEL_CLOSED, CONSUMER_STATE_CLOSED, CONSUMER_STATE_CONNECTION_CLOSED, CONSUMER_STATE_OPEN, CONSUMER_STATE_OPENING, CONSUMER_STATE_USER_CLOSED, Channel, Consumer, MaxEmptyFrameSize, _, async, bson, classes, debug, defaults, methodTable, methods, os, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  os = require('os');

  debug = require('./config').debug('amqp:Consumer');

  Channel = require('./Channel');

  _ = require('underscore');

  async = require('async');

  defaults = require('./defaults');

  bson = require('bson');

  BSON = new bson.BSONPure.BSON();

  ref = require('./config').protocol, methodTable = ref.methodTable, classes = ref.classes, methods = ref.methods;

  MaxEmptyFrameSize = require('./config').constants.MaxEmptyFrameSize;

  CONSUMER_STATE_OPEN = 'open';

  CONSUMER_STATE_OPENING = 'opening';

  CONSUMER_STATE_CLOSED = 'closed';

  CONSUMER_STATE_USER_CLOSED = 'user_closed';

  CONSUMER_STATE_CHANNEL_CLOSED = 'channel_closed';

  CONSUMER_STATE_CONNECTION_CLOSED = 'connection_closed';

  CONSUMER_STATES_CLOSED = [CONSUMER_STATE_CLOSED, CONSUMER_STATE_USER_CLOSED, CONSUMER_STATE_CONNECTION_CLOSED, CONSUMER_STATE_CHANNEL_CLOSED];

  Consumer = (function(superClass) {
    extend(Consumer, superClass);

    function Consumer(connection, channel) {
      this._onContent = bind(this._onContent, this);
      this._channelClosed = bind(this._channelClosed, this);
      this._channelOpen = bind(this._channelOpen, this);
      this._consumerStateOpenPreflight = bind(this._consumerStateOpenPreflight, this);
      this._basicConsumePreflight = bind(this._basicConsumePreflight, this);
      this._consume = bind(this._consume, this);
      this.cancel = bind(this.cancel, this);
      this.close = bind(this.close, this);
      debug(2, (function(_this) {
        return function() {
          return "channel open for consumer " + channel;
        };
      })(this));
      Consumer.__super__.constructor.call(this, connection, channel);
      this.consumerState = CONSUMER_STATE_CLOSED;
      this.messageHandler = null;
      this.incomingMessage = null;
      this.outstandingDeliveryTags = {};
      return this;
    }

    Consumer.prototype.consume = function(queueName, options, messageHandler, cb) {
      var consumeOptions, providedOptions, qosOptions, ref1;
      if (typeof options === 'function') {
        if (typeof messageHandler === 'function') {
          cb = messageHandler;
        }
        messageHandler = options;
        options = {};
      }
      this.consumerTag = (ref1 = options.consumerTag) != null ? ref1 : (os.hostname()) + "-" + process.pid + "-" + (Date.now());
      debug(2, (function(_this) {
        return function() {
          return "Consuming to " + queueName + " on channel " + _this.channel + " " + _this.consumerTag;
        };
      })(this));
      this.consumerState = CONSUMER_STATE_OPENING;
      if (options.prefetchCount != null) {
        this.qos = true;
        providedOptions = {
          prefetchCount: options.prefetchCount
        };
        if (options.global != null) {
          providedOptions['global'] = options.global;
        }
        qosOptions = _.defaults(providedOptions, defaults.basicQos);
        options.noAck = false;
        delete options.prefetchCount;
      } else {
        this.qos = false;
        options.noAck = true;
      }
      consumeOptions = _.defaults(options, defaults.basicConsume);
      consumeOptions.queue = queueName;
      consumeOptions.consumerTag = this.consumerTag;
      if (messageHandler != null) {
        this.messageHandler = messageHandler;
      }
      if (this.messageHandler == null) {
        return typeof cb === "function" ? cb("No message handler") : void 0;
      }
      this.consumeOptions = consumeOptions;
      this.qosOptions = qosOptions;
      this._consume(cb);
      return this;
    };

    Consumer.prototype.close = function(cb) {
      return this.cancel((function(_this) {
        return function() {
          _this.consumerState = CONSUMER_STATE_USER_CLOSED;
          Consumer.__super__.close.call(_this);
          return typeof cb === "function" ? cb() : void 0;
        };
      })(this));
    };

    Consumer.prototype.cancel = function(cb) {
      var ref1;
      if (!(ref1 = this.consumerState, indexOf.call(CONSUMER_STATES_CLOSED, ref1) >= 0)) {
        return this.taskPushPreflight(methods.basicCancel, {
          consumerTag: this.consumerTag,
          noWait: false
        }, methods.basicCancelOk, this._consumerStateOpenPreflight, cb);
      } else {
        return typeof cb === "function" ? cb() : void 0;
      }
    };

    Consumer.prototype.pause = function(cb) {
      var ref1;
      if (!(ref1 = this.consumerState, indexOf.call(CONSUMER_STATES_CLOSED, ref1) >= 0)) {
        return this.cancel((function(_this) {
          return function(err, res) {
            _this.consumerState = CONSUMER_STATE_USER_CLOSED;
            return typeof cb === "function" ? cb(err, res) : void 0;
          };
        })(this));
      } else {
        return typeof cb === "function" ? cb() : void 0;
      }
    };

    Consumer.prototype.resume = function(cb) {
      var ref1;
      if (ref1 = this.consumerState, indexOf.call(CONSUMER_STATES_CLOSED, ref1) >= 0) {
        return this._consume(cb);
      } else {
        return typeof cb === "function" ? cb() : void 0;
      }
    };

    Consumer.prototype.flow = function(active, cb) {
      if (active) {
        return this.resume(cb);
      } else {
        return this.pause(cb);
      }
    };

    Consumer.prototype.setQos = function(prefetchCount, cb) {
      var global, qosOptions, ref1, ref2, ref3, ref4;
      if (typeof prefetchCount === 'function') {
        cb = prefetchCount;
        qosOptions = this.qosOptions;
      } else {
        if (prefetchCount !== this.qosOptions.prefetchCount && ((ref1 = this.connection.serverProperties) != null ? ref1.product : void 0) === 'RabbitMQ' && (((ref2 = this.connection.serverProperties) != null ? (ref3 = ref2.capabilities) != null ? ref3.per_consumer_qos : void 0 : void 0) === true || ((ref4 = this.connection.serverProperties) != null ? ref4.version : void 0) === "3.3.0")) {
          global = true;
        }
        qosOptions = _.defaults({
          prefetchCount: prefetchCount,
          global: global
        }, this.qosOptions);
      }
      return this.taskPush(methods.basicQos, qosOptions, methods.basicQosOk, cb);
    };

    Consumer.prototype._consume = function(cb) {
      return async.series([
        (function(_this) {
          return function(next) {
            if (_this.qos) {
              return _this.setQos(next);
            } else {
              return next();
            }
          };
        })(this), (function(_this) {
          return function(next) {
            return _this.taskQueuePushRaw({
              type: 'method',
              method: methods.basicConsume,
              args: _this.consumeOptions,
              okMethod: methods.basicConsumeOk,
              preflight: _this._basicConsumePreflight
            }, next);
          };
        })(this), (function(_this) {
          return function(next) {
            _this.consumerState = CONSUMER_STATE_OPEN;
            return next();
          };
        })(this)
      ], cb);
    };

    Consumer.prototype._basicConsumePreflight = function() {
      return this.consumerState !== CONSUMER_STATE_OPEN;
    };

    Consumer.prototype._consumerStateOpenPreflight = function() {
      return this.consumerState === CONSUMER_STATE_OPEN;
    };

    Consumer.prototype._channelOpen = function() {
      if ((this.consumeOptions != null) && this.consumerState === CONSUMER_STATE_CONNECTION_CLOSED) {
        return this._consume();
      }
    };

    Consumer.prototype._channelClosed = function(reason) {
      if (this.consumerState === CONSUMER_STATE_CHANNEL_CLOSED) {
        if (reason == null) {
          reason = {};
        }
        this.emit('error', reason);
      }
      this.outstandingDeliveryTags = {};
      if (this.connection.state === 'open' && this.consumerState === CONSUMER_STATE_OPEN) {
        this.consumerState = CONSUMER_STATE_CHANNEL_CLOSED;
        return this._consume();
      } else {
        return this.consumerState = CONSUMER_STATE_CONNECTION_CLOSED;
      }
    };

    Consumer.prototype.ack = function() {
      var basicAckOptions;
      if (this.subscription.qos && (this.subscription.outstandingDeliveryTags[this.deliveryTag] != null)) {
        delete this.subscription.outstandingDeliveryTags[this.deliveryTag];
        if (this.subscription.state === 'open') {
          basicAckOptions = {
            deliveryTag: this.deliveryTag,
            multiple: false
          };
          return this.subscription.connection._sendMethod(this.subscription.channel, methods.basicAck, basicAckOptions);
        }
      }
    };

    Consumer.prototype.reject = function() {
      var basicAckOptions;
      if (this.subscription.qos && (this.subscription.outstandingDeliveryTags[this.deliveryTag] != null)) {
        delete this.subscription.outstandingDeliveryTags[this.deliveryTag];
        if (this.subscription.state === 'open') {
          basicAckOptions = {
            deliveryTag: this.deliveryTag,
            requeue: false
          };
          return this.subscription.connection._sendMethod(this.subscription.channel, methods.basicReject, basicAckOptions);
        }
      }
    };

    Consumer.prototype.retry = function() {
      var basicAckOptions;
      if (this.subscription.qos && (this.subscription.outstandingDeliveryTags[this.deliveryTag] != null)) {
        delete this.subscription.outstandingDeliveryTags[this.deliveryTag];
        if (this.subscription.state === 'open') {
          basicAckOptions = {
            deliveryTag: this.deliveryTag,
            requeue: true
          };
          return this.subscription.connection._sendMethod(this.subscription.channel, methods.basicReject, basicAckOptions);
        }
      }
    };

    Consumer.prototype._onMethod = function(channel, method, args) {
      debug(3, function() {
        return "onMethod " + method.name + ", " + (JSON.stringify(args));
      });
      switch (method) {
        case methods.basicDeliver:
          delete args['consumerTag'];
          if (this.qos) {
            return this.incomingMessage = args;
          } else {
            return this.incomingMessage = args;
          }
          break;
        case methods.basicCancel:
          debug(1, function() {
            return "basicCancel";
          });
          this.consumerState = CONSUMER_STATE_CLOSED;
          if (this.listeners('cancel').length > 0) {
            return this.emit('cancel', "Server initiated basicCancel");
          } else {
            return this.emit('error', "Server initiated basicCancel");
          }
      }
    };

    Consumer.prototype._onContentHeader = function(channel, classInfo, weight, properties, size) {
      debug(3, function() {
        return "_onContentHeader " + properties;
      });
      this.incomingMessage = _.extend(this.incomingMessage, {
        weight: weight,
        properties: properties,
        size: size
      });
      if (size > this.connection.frameMax - MaxEmptyFrameSize) {
        this.incomingMessage.data = new Buffer(size);
        return this.incomingMessage.data.used = 0;
      }
    };

    Consumer.prototype._onContent = function(channel, data) {
      var message, ref1, ref2, ref3;
      if ((this.incomingMessage.data == null) && this.incomingMessage.size === data.length) {
        this.incomingMessage.data = data;
      } else {
        data.copy(this.incomingMessage.data, this.incomingMessage.data.used);
        this.incomingMessage.data.used += data.length;
      }
      if (this.incomingMessage.data.used >= this.incomingMessage.size) {
        message = _.clone(this.incomingMessage);
        message.raw = this.incomingMessage.data;
        if (((ref1 = this.incomingMessage.properties) != null ? ref1.contentType : void 0) === "application/json") {
          Object.defineProperty(message, "data", {
            get: (function(_this) {
              return function() {
                var e, error;
                try {
                  return JSON.parse(message.raw.toString());
                } catch (error) {
                  e = error;
                  console.error(e);
                  return message.raw;
                }
              };
            })(this)
          });
        } else if (((ref2 = this.incomingMessage.properties) != null ? ref2.contentType : void 0) === "application/bson") {
          Object.defineProperty(message, "data", {
            get: (function(_this) {
              return function() {
                var e, error;
                try {
                  return BSON.deserialize(message.raw);
                } catch (error) {
                  e = error;
                  console.error(e);
                  return message.raw;
                }
              };
            })(this)
          });
        } else if (((ref3 = this.incomingMessage.properties) != null ? ref3.contentType : void 0) === "string/utf8") {
          Object.defineProperty(message, "data", {
            get: (function(_this) {
              return function() {
                var e, error;
                try {
                  return message.raw.toString('utf8');
                } catch (error) {
                  e = error;
                  console.error(e);
                  return message.raw;
                }
              };
            })(this)
          });
        } else {
          Object.defineProperty(message, "data", {
            get: (function(_this) {
              return function() {
                return message.raw;
              };
            })(this)
          });
        }
        if (this.qos) {
          message.ack = this.ack;
          message.reject = this.reject;
          message.retry = this.retry;
          message.subscription = this;
        }
        this.outstandingDeliveryTags[this.incomingMessage.deliveryTag] = true;
        return this.messageHandler(message);
      }
    };

    return Consumer;

  })(Channel);

  module.exports = Consumer;

}).call(this);

// Generated by CoffeeScript 1.10.0

/*

Channel Manager

we track and manage all the channels on a connection.
we will dynamically add and remove publish channels... maybe
we track confirm channels and non confirm channels seperately.
 */

(function() {
  var ChannelManager, Consumer, Publisher, TemporaryChannel, publisherPoolSize,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  publisherPoolSize = 1;

  Publisher = require('./Publisher');

  Consumer = require('./Consumer');

  TemporaryChannel = require('./TemporaryChannel');

  ChannelManager = (function() {
    function ChannelManager(connection) {
      this.temporaryChannel = bind(this.temporaryChannel, this);
      this.publisherChannel = bind(this.publisherChannel, this);
      this.nextChannelNumber = bind(this.nextChannelNumber, this);
      this.connection = connection;
      this.channels = this.connection.channels;
      this.publisherConfirmChannels = [];
      this.publisherChannels = [];
      this.tempChannel = null;
      this.queue = null;
      this.exchange = null;
      this.channelCount = this.connection.channelCount;
    }

    ChannelManager.prototype.nextChannelNumber = function() {
      var nextChannelNumber;
      this.channelCount++;
      nextChannelNumber = this.channelCount;
      return nextChannelNumber;
    };

    ChannelManager.prototype.publisherChannel = function(confirm, cb) {
      var channel, i, p, pool;
      if (typeof confirm === 'function') {
        cb = confirm;
        confirm = false;
      }
      if (confirm) {
        pool = this.publisherConfirmChannels;
      } else {
        pool = this.publisherChannels;
      }
      if (pool.length < publisherPoolSize) {
        channel = this.nextChannelNumber();
        p = new Publisher(this.connection, channel, confirm);
        this.channels[channel] = p;
        pool.push(p);
        return cb(null, p.channel);
      } else {
        i = Math.floor(Math.random() * pool.length);
        return cb(null, pool[i].channel);
      }
    };

    ChannelManager.prototype.temporaryChannel = function(cb) {
      var channel;
      if (this.tempChannel != null) {
        if (typeof cb === "function") {
          cb(null, this.tempChannel);
        }
        return this.tempChannel;
      }
      channel = this.nextChannelNumber();
      this.tempChannel = new TemporaryChannel(this.connection, channel, (function(_this) {
        return function(err, res) {
          return typeof cb === "function" ? cb(err, _this.tempChannel) : void 0;
        };
      })(this));
      this.channels[channel] = this.tempChannel;
      return this.tempChannel;
    };

    ChannelManager.prototype.consumerChannel = function(cb) {
      var channel, s;
      channel = this.nextChannelNumber();
      s = new Consumer(this.connection, channel);
      this.channels[channel] = s;
      return cb(null, channel);
    };

    ChannelManager.prototype.channelReassign = function(channel) {
      var newChannelNumber;
      delete this.channels[channel.channel];
      newChannelNumber = this.nextChannelNumber();
      channel.channel = newChannelNumber;
      return this.channels[newChannelNumber] = channel;
    };

    ChannelManager.prototype.channelClosed = function(channelNumber) {
      return delete this.channels[channelNumber];
    };

    ChannelManager.prototype.isChannelClosed = function(channelNumber) {
      return !this.channels.hasOwnProperty(channelNumber);
    };

    return ChannelManager;

  })();

  module.exports = ChannelManager;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var AMQPParser, ChannelManager, Connection, EndFrame, EventEmitter, Exchange, FrameType, HeartbeatFrame, Queue, _, async, classes, debug, defaults, methodTable, methods, net, ref, ref1, ref2, serializeFields, serializeInt, tls,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  debug = require('./config').debug('amqp:Connection');

  EventEmitter = require('events').EventEmitter;

  net = require('net');

  tls = require('tls');

  _ = require('underscore');

  async = require('async');

  defaults = require('./defaults');

  ref = require('./config').protocol, methodTable = ref.methodTable, classes = ref.classes, methods = ref.methods;

  ref1 = require('./config').constants, FrameType = ref1.FrameType, HeartbeatFrame = ref1.HeartbeatFrame, EndFrame = ref1.EndFrame;

  ref2 = require('./serializationHelpers'), serializeInt = ref2.serializeInt, serializeFields = ref2.serializeFields;

  Queue = require('./Queue');

  Exchange = require('./Exchange');

  AMQPParser = require('./AMQPParser');

  ChannelManager = require('./ChannelManager');

  if (process.env.AMQP_TEST != null) {
    defaults.connection.reconnectDelayTime = 100;
  }

  Connection = (function(superClass) {
    extend(Connection, superClass);


    /*
    
      host: localhost | [localhost, localhost] | [{host: localhost, port: 5672}, {host: localhost, port: 5673}]
      port: int
      vhost: %2F
      hostRandom: default false, if host is an array
    
      @state : opening | open | closed | reconnecting | destroyed
     */

    function Connection(args, cb) {
      this._onMethod = bind(this._onMethod, this);
      this._onContent = bind(this._onContent, this);
      this._onContentHeader = bind(this._onContentHeader, this);
      this._sendBody = bind(this._sendBody, this);
      this._sendHeader = bind(this._sendHeader, this);
      this._sendMethod = bind(this._sendMethod, this);
      this._missedHeartbeat = bind(this._missedHeartbeat, this);
      this._sendHeartbeat = bind(this._sendHeartbeat, this);
      this._resetSendHeartbeatTimer = bind(this._resetSendHeartbeatTimer, this);
      this._clearHeartbeatTimer = bind(this._clearHeartbeatTimer, this);
      this._resetHeartbeatTimer = bind(this._resetHeartbeatTimer, this);
      this._resetAllHeartbeatTimers = bind(this._resetAllHeartbeatTimers, this);
      this._receivedHeartbeat = bind(this._receivedHeartbeat, this);
      this._closed = bind(this._closed, this);
      this._reestablishChannels = bind(this._reestablishChannels, this);
      this._connectionClosedEvent = bind(this._connectionClosedEvent, this);
      this._connectionErrorEvent = bind(this._connectionErrorEvent, this);
      this._connectedFirst = bind(this._connectedFirst, this);
      this.crashOOO = bind(this.crashOOO, this);
      this.close = bind(this.close, this);
      this.publish = bind(this.publish, this);
      this.updateConnectionOptionsHostInformation = bind(this.updateConnectionOptionsHostInformation, this);
      this.id = Math.round(Math.random() * 1000);
      if (typeof args === 'function') {
        cb = args;
        args = {};
      }
      if (cb != null) {
        cb = _.once(cb);
      }
      this.cb = cb;
      this.state = 'opening';
      this.connectionOptions = _.defaults(args, defaults.connection);
      this.channelCount = 0;
      this.channels = {
        0: this
      };
      this.queues = {};
      this.exchanges = {};
      this.channelMax = this.connectionOptions.channelMax;
      this.frameMax = this.connectionOptions.frameMax;
      this.sendBuffer = new Buffer(this.frameMax);
      this.channelManager = new ChannelManager(this);
      async.series([
        (function(_this) {
          return function(next) {
            _this.connectionOptions.hosts = _.flatten([_this.connectionOptions.host]).map(function(uri) {
              var host, port, ref3;
              if ((uri.port != null) && (uri.host != null)) {
                return {
                  host: uri.host.toLowerCase(),
                  port: parseInt(uri.port)
                };
              } else if (typeof uri === 'string' && uri.indexOf(":") !== -1) {
                ref3 = uri.split(":"), host = ref3[0], port = ref3[1];
                return {
                  host: host.toLowerCase(),
                  port: parseInt(port)
                };
              } else if (typeof uri === 'string') {
                return {
                  host: uri.toLowerCase(),
                  port: !_this.connectionOptions.ssl ? _this.connectionOptions.port : _this.connectionOptions.sslPort
                };
              } else {
                throw new Error("we dont know what do do with the host " + uri);
              }
            });
            _this.connectionOptions.hosti = 0;
            if (_this.connectionOptions.hostRandom) {
              _this.connectionOptions.hosti = Math.floor(Math.random() * _this.connectionOptions.hosts.length);
            }
            _this.updateConnectionOptionsHostInformation();
            return next();
          };
        })(this), (function(_this) {
          return function(next) {
            var ref3;
            if (((ref3 = _this.connectionOptions.rabbitMasterNode) != null ? ref3.queue : void 0) != null) {
              return require('./plugins/rabbit').masterNode(_this, _this.connectionOptions.rabbitMasterNode.queue, next);
            } else {
              return next();
            }
          };
        })(this), (function(_this) {
          return function(next) {
            var ref3, setupConnectionListeners, setupTlsConnection, tlsOptions;
            setupConnectionListeners = function() {
              var connectionEvent;
              if (_this.connectionOptions.ssl) {
                connectionEvent = 'secureConnect';
              } else {
                connectionEvent = 'connect';
              }
              _this.connection.once(connectionEvent, function() {
                return _this._connectedFirst();
              });
              _this.connection.on(connectionEvent, function() {
                return _this._connected();
              });
              _this.connection.on('error', _this._connectionErrorEvent);
              return _this.connection.on('close', _this._connectionClosedEvent);
            };
            if (_this.connectionOptions.ssl) {
              tlsOptions = (ref3 = _this.connectionOptions.sslOptions) != null ? ref3 : {};
              setupTlsConnection = function() {
                var ref4;
                if (_this.connection != null) {
                  _this.connection.removeAllListeners();
                  if (((ref4 = _this.connection) != null ? ref4.socket : void 0) != null) {
                    _this.connection.socket.end();
                  }
                }
                _this.connection = tls.connect(_this.connectionOptions.port, _this.connectionOptions.host, tlsOptions, function() {
                  return _this.connection.on('error', function() {
                    return _this.connection.emit('close');
                  });
                });
                _this.connection.connect = setupTlsConnection;
                return setupConnectionListeners();
              };
              setupTlsConnection();
            } else {
              _this.connection = net.connect(_this.connectionOptions.port, _this.connectionOptions.host);
              setupConnectionListeners();
            }
            if ((_this.connectionOptions.connectTimeout != null) && !_this.connectionOptions.reconnect) {
              clearTimeout(_this._connectTimeout);
              _this._connectTimeout = setTimeout(function() {
                debug(1, function() {
                  return "Connection timeout triggered";
                });
                _this.close();
                return typeof cb === "function" ? cb({
                  code: 'T',
                  message: 'Connection Timeout',
                  host: _this.connectionOptions.host,
                  port: _this.connectionOptions.port
                }) : void 0;
              }, _this.connectionOptions.connectTimeout);
            }
            return next();
          };
        })(this)
      ], function(e, r) {
        if ((e != null) && (cb != null)) {
          return cb(e);
        }
      });
      if (cb != null) {
        this.once('ready', cb);
      }
      this.on('close', this._closed);
      Connection.__super__.constructor.call(this);
      return this;
    }

    Connection.prototype.updateConnectionOptionsHostInformation = function() {
      this.connectionOptions.host = this.connectionOptions.hosts[this.connectionOptions.hosti].host;
      return this.connectionOptions.port = this.connectionOptions.hosts[this.connectionOptions.hosti].port;
    };

    Connection.prototype.queue = function(args, cb) {
      if ((cb == null) || typeof cb !== 'function') {
        return new Queue(this.channelManager.temporaryChannel(), args);
      } else {
        return this.channelManager.temporaryChannel(function(err, channel) {
          var q;
          if (err != null) {
            return cb(err);
          }
          return q = new Queue(channel, args, cb);
        });
      }
    };

    Connection.prototype.exchange = function(args, cb) {
      if ((cb == null) || typeof cb !== 'function') {
        return new Exchange(this.channelManager.temporaryChannel(), args);
      } else {
        return this.channelManager.temporaryChannel(function(err, channel) {
          var e;
          if (err != null) {
            return cb(err);
          }
          return e = new Exchange(channel, args, cb);
        });
      }
    };

    Connection.prototype.consume = function(queueName, options, messageParser, cb) {
      return this.channelManager.consumerChannel((function(_this) {
        return function(err, channel) {
          var consumerChannel;
          if (err == null) {
            consumerChannel = _this.channels[channel];
          }
          if ((err != null) || (consumerChannel == null)) {
            return cb({
              err: err,
              channel: channel
            });
          }
          return consumerChannel.consume(queueName, options, messageParser, cb);
        };
      })(this));
    };

    Connection.prototype.publish = function(exchange, routingKey, data, options, cb) {
      var confirm;
      if ((cb != null) && options.confirm) {
        confirm = true;
      } else {
        confirm = false;
      }
      return this.channelManager.publisherChannel(confirm, (function(_this) {
        return function(err, channel) {
          var publishChannel;
          if (err == null) {
            publishChannel = _this.channels[channel];
          }
          if ((err != null) || (publishChannel == null)) {
            return cb({
              err: err,
              channel: channel
            });
          }
          return publishChannel.publish(exchange, routingKey, data, options, cb);
        };
      })(this));
    };

    Connection.prototype.close = function(cb) {
      this._clearHeartbeatTimer();
      return _.defer((function(_this) {
        return function() {
          var forceConnectionClose, state;
          _this.state = 'destroyed';
          if (cb != null) {
            cb = _.once(cb);
          }
          if (_this.connection.writable) {
            _this._sendMethod(0, methods.connectionClose, {
              classId: 0,
              methodId: 0,
              replyCode: 200,
              replyText: 'closed'
            });
          } else {
            return typeof cb === "function" ? cb() : void 0;
          }
          state = {
            write: _this.connection.writable,
            read: _this.connection.readable
          };
          forceConnectionClose = setTimeout(function() {
            _this.connection.destroy();
            return typeof cb === "function" ? cb() : void 0;
          }, 1000);
          return _this.connection.once('close', function() {
            clearTimeout(forceConnectionClose);
            return typeof cb === "function" ? cb() : void 0;
          });
        };
      })(this));
    };

    Connection.prototype.crashOOO = function() {
      if (process.env.AMQP_TEST == null) {
        return true;
      }
      debug("Trying to crash connection by an oow op");
      return this._sendBody(this.channel, new Buffer(100), {});
    };

    Connection.prototype._connectedFirst = function() {
      return debug(1, (function(_this) {
        return function() {
          return "Connected to " + _this.connectionOptions.host + ":" + _this.connectionOptions.port;
        };
      })(this));
    };

    Connection.prototype._connected = function() {
      clearTimeout(this._connectTimeout);
      this._resetAllHeartbeatTimers();
      return this._setupParser(this._reestablishChannels);
    };

    Connection.prototype._connectionErrorEvent = function(e, r) {
      if (this.state !== 'destroyed') {
        debug(1, (function(_this) {
          return function() {
            return ["Connection Error ", e, r, _this.connectionOptions.host];
          };
        })(this));
      }
      if (!this.connectionOptions.reconnect) {
        if (this.cb != null) {
          return this.cb(e, r);
        } else {
          return this.emit('error', e);
        }
      }
    };

    Connection.prototype._connectionClosedEvent = function(had_error) {
      var channel, channelNumber, ref3;
      ref3 = this.channels;
      for (channelNumber in ref3) {
        channel = ref3[channelNumber];
        if (typeof channel._connectionClosed === "function") {
          channel._connectionClosed();
        }
      }
      clearTimeout(this._connectTimeout);
      if (this.state === "open") {
        this.emit('close');
      }
      if (this.state !== 'destroyed') {
        if (!this.connectionOptions.reconnect) {
          debug(1, function() {
            return "Connection closed not reconnecting...";
          });
          return;
        }
        this.state = 'reconnecting';
        debug(1, function() {
          return "Connection closed reconnecting...";
        });
        return _.delay((function(_this) {
          return function() {
            if (_this.connectionOptions.hosts.length > 1) {
              _this.connectionOptions.hosti = (_this.connectionOptions.hosti + 1) % _this.connectionOptions.hosts.length;
              _this.updateConnectionOptionsHostInformation();
            }
            return _this.connection.connect(_this.connectionOptions.port, _this.connectionOptions.host);
          };
        })(this), this.connectionOptions.reconnectDelayTime);
      }
    };

    Connection.prototype._reestablishChannels = function() {
      return async.forEachSeries(_.keys(this.channels), (function(_this) {
        return function(channel, done) {
          var base;
          if (channel === "0") {
            return done();
          } else {
            if (_this.channelManager.isChannelClosed(channel)) {
              return done();
            } else {
              return typeof (base = _this.channels[channel]).reset === "function" ? base.reset(done) : void 0;
            }
          }
        };
      })(this));
    };

    Connection.prototype._closed = function() {
      return this._clearHeartbeatTimer();
    };

    Connection.prototype._receivedHeartbeat = function() {
      debug(4, (function(_this) {
        return function() {
          return "♥ heartbeat";
        };
      })(this));
      return this._resetHeartbeatTimer();
    };

    Connection.prototype._resetAllHeartbeatTimers = function() {
      this._resetSendHeartbeatTimer();
      return this._resetHeartbeatTimer();
    };

    Connection.prototype._resetHeartbeatTimer = function() {
      debug(6, (function(_this) {
        return function() {
          return "_resetHeartbeatTimer";
        };
      })(this));
      clearInterval(this.heartbeatTimer);
      return this.heartbeatTimer = setInterval(this._missedHeartbeat, this.connectionOptions.heartbeat * 2);
    };

    Connection.prototype._clearHeartbeatTimer = function() {
      debug(6, (function(_this) {
        return function() {
          return "_clearHeartbeatTimer";
        };
      })(this));
      clearInterval(this.heartbeatTimer);
      clearInterval(this.sendHeartbeatTimer);
      this.heartbeatTimer = null;
      return this.sendHeartbeatTimer = null;
    };

    Connection.prototype._resetSendHeartbeatTimer = function() {
      debug(6, (function(_this) {
        return function() {
          return "_resetSendHeartbeatTimer";
        };
      })(this));
      clearInterval(this.sendHeartbeatTimer);
      return this.sendHeartbeatTimer = setInterval(this._sendHeartbeat, this.connectionOptions.heartbeat);
    };

    Connection.prototype._sendHeartbeat = function() {
      return this.connection.write(HeartbeatFrame);
    };

    Connection.prototype._missedHeartbeat = function() {
      if (this.state === 'open') {
        debug(1, function() {
          return "We missed a heartbeat, destroying the connection.";
        });
        this.connection.destroy();
      }
      return this._clearHeartbeatTimer();
    };

    Connection.prototype._setupParser = function(cb) {
      if (this.parser != null) {
        this.parser.removeAllListeners();
      }
      this.parser = new AMQPParser('0-9-1', 'client', this.connection);
      this.parser.on('method', this._onMethod);
      this.parser.on('contentHeader', this._onContentHeader);
      this.parser.on('content', this._onContent);
      this.parser.on('heartbeat', this._receivedHeartbeat);
      this.connection.removeAllListeners('data');
      this.connection.on('data', (function(_this) {
        return function(data) {
          return _this.parser.execute(data);
        };
      })(this));
      if (cb != null) {
        this.removeListener('ready', cb);
        return this.once('ready', cb);
      }
    };

    Connection.prototype._sendMethod = function(channel, method, args) {
      var b, endIndex, lengthIndex, methodBuffer, ref3, startIndex;
      if (channel !== 0 && ((ref3 = this.state) === 'opening' || ref3 === 'reconnecting')) {
        return this.once('ready', (function(_this) {
          return function() {
            return _this._sendMethod(channel, method, args);
          };
        })(this));
      }
      debug(3, function() {
        return channel + " < " + method.name;
      });
      b = this.sendBuffer;
      b.used = 0;
      b[b.used++] = 1;
      serializeInt(b, 2, channel);
      lengthIndex = b.used;
      serializeInt(b, 4, 0);
      startIndex = b.used;
      serializeInt(b, 2, method.classIndex);
      serializeInt(b, 2, method.methodIndex);
      serializeFields(b, method.fields, args, true);
      endIndex = b.used;
      b.used = lengthIndex;
      serializeInt(b, 4, endIndex - startIndex);
      b.used = endIndex;
      b[b.used++] = 206;
      methodBuffer = new Buffer(b.used);
      b.copy(methodBuffer, 0, 0, b.used);
      this.connection.write(methodBuffer);
      return this._resetSendHeartbeatTimer();
    };

    Connection.prototype._sendHeader = function(channel, size, args) {
      var b, bodyEnd, bodyStart, classInfo, field, headerBuffer, i, j, k, len, len1, lengthStart, propertyFields, propertyFlag, propertyFlags, ref3;
      debug(3, (function(_this) {
        return function() {
          return _this.id + " " + channel + " < header " + size;
        };
      })(this));
      b = this.sendBuffer;
      classInfo = classes[60];
      b.used = 0;
      b[b.used++] = 2;
      serializeInt(b, 2, channel);
      lengthStart = b.used;
      serializeInt(b, 4, 0);
      bodyStart = b.used;
      serializeInt(b, 2, classInfo.index);
      serializeInt(b, 2, 0);
      serializeInt(b, 8, size);
      propertyFlags = [0];
      propertyFields = [];

      /*
      The property flags are an array of bits that indicate the presence or absence of each
      property value in sequence. The bits are ordered from most high to low - bit 15 indicates
      the first property.
      
      The property flags can specify more than 16 properties. If the last bit (0) is set, this indicates that a
      further property flags field follows. There are many property flags fields as needed.
       */
      ref3 = classInfo.fields;
      for (i = j = 0, len = ref3.length; j < len; i = ++j) {
        field = ref3[i];
        if ((i + 1) % 16 === 0) {
          propertyFlags[Math.floor((i - 1) / 15)] |= 1 << 0;
          propertyFlags.push(0);
        }
        if (args[field.name]) {
          propertyFlags[Math.floor(i / 15)] |= 1 << (15 - i);
        }
      }
      for (k = 0, len1 = propertyFlags.length; k < len1; k++) {
        propertyFlag = propertyFlags[k];
        serializeInt(b, 2, propertyFlag);
      }
      serializeFields(b, classInfo.fields, args, false);
      bodyEnd = b.used;
      b.used = lengthStart;
      serializeInt(b, 4, bodyEnd - bodyStart);
      b.used = bodyEnd;
      b[b.used++] = 206;
      headerBuffer = new Buffer(b.used);
      b.copy(headerBuffer, 0, 0, b.used);
      this.connection.write(headerBuffer);
      return this._resetSendHeartbeatTimer();
    };

    Connection.prototype._sendBody = function(channel, body, args, cb) {
      var h, length, offset;
      if (body instanceof Buffer) {
        this._sendHeader(channel, body.length, args);
        offset = 0;
        while (offset < body.length) {
          length = Math.min(body.length - offset, this.frameMax);
          h = new Buffer(7);
          h.used = 0;
          h[h.used++] = 3;
          serializeInt(h, 2, channel);
          serializeInt(h, 4, length);
          debug(3, (function(_this) {
            return function() {
              return _this.id + " " + channel + " < body " + offset + ", " + (offset + length) + " of " + body.length;
            };
          })(this));
          this.connection.write(h);
          this.connection.write(body.slice(offset, offset + length));
          this.connection.write(EndFrame);
          this._resetSendHeartbeatTimer();
          offset += this.frameMax;
        }
        if (typeof cb === "function") {
          cb();
        }
        return true;
      } else {
        debug(1, function() {
          return "invalid body type";
        });
        if (typeof cb === "function") {
          cb("Invalid body type for publish, expecting a buffer");
        }
        return false;
      }
    };

    Connection.prototype._onContentHeader = function(channel, classInfo, weight, properties, size) {
      this._resetHeartbeatTimer();
      channel = this.channels[channel];
      if ((channel != null ? channel._onContentHeader : void 0) != null) {
        return channel._onContentHeader(channel, classInfo, weight, properties, size);
      } else {
        return debug(1, function() {
          return [
            "unhandled -- _onContentHeader " + channel + " > ", {
              classInfo: classInfo,
              properties: properties,
              size: size
            }
          ];
        });
      }
    };

    Connection.prototype._onContent = function(channel, data) {
      this._resetHeartbeatTimer();
      channel = this.channels[channel];
      if ((channel != null ? channel._onContent : void 0) != null) {
        return channel._onContent(channel, data);
      } else {
        return debug(1, function() {
          return "unhandled -- _onContent " + channel + " > " + data.length;
        });
      }
    };

    Connection.prototype._onMethod = function(channel, method, args) {
      var e;
      this._resetHeartbeatTimer();
      if (channel > 0) {
        if (this.channels[channel] == null) {
          return debug(1, function() {
            return "Recieved a message on untracked channel " + channel + ", " + method.name + " " + (JSON.stringify(args));
          });
        }
        if (this.channels[channel]._onChannelMethod == null) {
          return debug(1, function() {
            return "Channel " + channel + " has no _onChannelMethod";
          });
        }
        return this.channels[channel]._onChannelMethod(channel, method, args);
      } else {
        switch (method) {
          case methods.connectionStart:
            if (args.versionMajor !== 0 && args.versionMinor !== 9) {
              this.emit('error', new Error("Bad server version"));
              return;
            }
            this.serverProperties = args.serverProperties;
            return this._sendMethod(0, methods.connectionStartOk, {
              clientProperties: this.connectionOptions.clientProperties,
              mechanism: 'AMQPLAIN',
              response: {
                LOGIN: this.connectionOptions.login,
                PASSWORD: this.connectionOptions.password
              },
              locale: 'en_US'
            });
          case methods.connectionTune:
            if ((args.channelMax != null) && args.channelMax !== 0 && args.channelMax < this.channelMax || this.channelMax === 0) {
              this.channelMax = args.channelMax;
            }
            if ((args.frameMax != null) && args.frameMax < this.frameMax) {
              this.frameMax = args.frameMax;
              this.sendBuffer = new Buffer(this.frameMax);
            }
            this._sendMethod(0, methods.connectionTuneOk, {
              channelMax: this.channelMax,
              frameMax: this.frameMax,
              heartbeat: this.connectionOptions.heartbeat / 1000
            });
            return this._sendMethod(0, methods.connectionOpen, {
              virtualHost: this.connectionOptions.vhost
            });
          case methods.connectionOpenOk:
            this.state = 'open';
            return this.emit('ready');
          case methods.connectionClose:
            this.state = 'closed';
            this._sendMethod(0, methods.connectionCloseOk, {});
            e = new Error(args.replyText);
            e.code = args.replyCode;
            return this.emit('close', e);
          case methods.connectionCloseOk:
            this.emit('close');
            return this.connection.destroy();
          default:
            return debug(1, function() {
              return "0 < no matched method on connection for " + method.name;
            });
        }
      }
    };

    return Connection;

  })(EventEmitter);

  module.exports = Connection;

}).call(this);

// Generated by CoffeeScript 1.10.0
(function() {
  var Channel, EventEmitter, OVERFLOW_PROTECTION, _, async, classes, debug, defaults, methodTable, methods, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  EventEmitter = require('events').EventEmitter;

  debug = require('./config').debug('amqp:Channel');

  async = require('async');

  _ = require('underscore');

  defaults = require('./defaults');

  ref = require('./config').protocol, methodTable = ref.methodTable, classes = ref.classes, methods = ref.methods;

  OVERFLOW_PROTECTION = 0;

  Channel = (function(superClass) {
    extend(Channel, superClass);

    function Channel(connection, channel) {
      this._callOutstandingCallbacks = bind(this._callOutstandingCallbacks, this);
      this._taskWorker = bind(this._taskWorker, this);
      this.queuePublish = bind(this.queuePublish, this);
      this.queueSendMethod = bind(this.queueSendMethod, this);
      this.taskQueuePushRaw = bind(this.taskQueuePushRaw, this);
      this.taskPushPreflight = bind(this.taskPushPreflight, this);
      this.taskPush = bind(this.taskPush, this);
      this.close = bind(this.close, this);
      this.crash = bind(this.crash, this);
      this.reset = bind(this.reset, this);
      this.channel = channel;
      this.connection = connection;
      this.state = 'closed';
      this.waitingCallbacks = {};
      this.queue = async.queue(this._taskWorker, 1);
      this.open();
      this.transactional = false;
    }

    Channel.prototype.temporaryChannel = function() {
      this.transactional = true;
      this.lastChannelAccess = Date.now();
      if (process.env.AMQP_TEST != null) {
        this.connection.connectionOptions.temporaryChannelTimeout = 200;
        this.connection.connectionOptions.temporaryChannelTimeoutCheck = 100;
      }
      if (this.channelTracker == null) {
        return this.channelTracker = setInterval((function(_this) {
          return function() {
            if (_this.lastChannelAccess < (Date.now() - _this.connection.connectionOptions.temporaryChannelTimeout)) {
              debug(4, function() {
                return "Closing channel due to inactivity";
              });
              return _this.close(true);
            }
          };
        })(this), this.connection.connectionOptions.temporaryChannelTimeoutCheck);
      }
    };

    Channel.prototype.open = function(cb) {
      if (this.state === "closed") {
        this.state = 'opening';
        if (cb != null) {
          this.waitForMethod(methods.channelOpenOk, cb);
        }
        this.connection._sendMethod(this.channel, methods.channelOpen, {});
        this.connection.channelCount++;
        if (this.transactional) {
          return this.temporaryChannel();
        }
      } else {
        if (cb != null) {
          return cb("state isn't closed.  not opening channel");
        }
      }
    };

    Channel.prototype.reset = function(cb) {
      this._callOutstandingCallbacks("Channel Opening or Reseting");
      if (this.state === 'closed' && (!this.transactional || this.listeners('open').length > 0 || (this.transactional && this.lastChannelAccess > (Date.now() - this.connection.connectionOptions.temporaryChannelTimeout)))) {
        debug(1, function() {
          return "State is closed... reconnecting";
        });
        return async.series([
          (function(_this) {
            return function(next) {
              return _this.open(next);
            };
          })(this), (function(_this) {
            return function(next) {
              return _this._onChannelReconnect(next);
            };
          })(this)
        ], cb);
      } else {
        if (cb != null) {
          return cb();
        }
      }
    };

    Channel.prototype.crash = function(cb) {
      if (process.env.AMQP_TEST == null) {
        if (typeof cb === "function") {
          cb();
        }
        return true;
      }
      debug("Trying to crash channel");
      this.connection._sendMethod(this.channel, methods.queuePurge, {
        queue: "idontexist"
      });
      if (cb != null) {
        return this.waitForMethod(methods.channelClose, cb);
      }
    };

    Channel.prototype.close = function(auto) {
      if ((auto == null) || !auto) {
        debug(1, function() {
          return "User requested channel close";
        });
      }
      clearInterval(this.channelTracker);
      this.channelTracker = null;
      if (this.state === 'open') {
        this.connection.channelCount--;
        this.state = 'closed';
        return this.connection._sendMethod(this.channel, methods.channelClose, {
          replyText: 'Goodbye',
          replyCode: 200,
          classId: 0,
          methodId: 0
        });
      }
    };

    Channel.prototype.waitForMethod = function(method, cb) {
      if (this.waitingCallbacks[method] == null) {
        this.waitingCallbacks[method.name] = [];
      }
      return this.waitingCallbacks[method.name].push(cb);
    };

    Channel.prototype.callbackForMethod = function(method) {
      var cb;
      if ((method == null) || (this.waitingCallbacks[method.name] == null)) {
        return function() {
          return true;
        };
      }
      cb = this.waitingCallbacks[method.name].shift();
      if (this.waitingCallbacks[method.name].length === 0) {
        delete this.waitingCallbacks[method.name];
      }
      return cb;
    };

    Channel.prototype._channelOpen = function() {
      return debug(4, function() {
        return "channel open called and should be overwritten";
      });
    };

    Channel.prototype._channelClosed = function() {
      return debug(4, function() {
        return "channel closed called and should be overwritten";
      });
    };

    Channel.prototype._onChannelReconnect = function(cb) {
      debug(4, function() {
        return "channel reconnect called and should be overwritten";
      });
      return cb();
    };

    Channel.prototype._onMethod = function(method, args) {
      return debug(3, function() {
        return "_onMethod MUST be overwritten by whoever extends Channel";
      });
    };

    Channel.prototype.taskPush = function(method, args, okMethod, cb) {
      return this.queue.push({
        type: 'method',
        method: method,
        args: args,
        okMethod: okMethod,
        cb: cb
      });
    };

    Channel.prototype.taskPushPreflight = function(method, args, okMethod, preflight, cb) {
      return this.queue.push({
        type: 'method',
        method: method,
        args: args,
        okMethod: okMethod,
        preflight: preflight,
        cb: cb
      });
    };

    Channel.prototype.taskQueuePushRaw = function(task, cb) {
      if ((cb != null) && (task != null)) {
        task.cb = cb;
      }
      return this.queue.push(task);
    };

    Channel.prototype.queueSendMethod = function(method, args, okMethod, cb) {
      return this.queue.push({
        type: 'method',
        method: method,
        args: args,
        okMethod: okMethod,
        cb: cb
      });
    };

    Channel.prototype.queuePublish = function(method, data, options) {
      return this.queue.push({
        type: 'publish',
        method: method,
        data: data,
        options: options
      });
    };

    Channel.prototype._taskWorker = function(task, done) {
      var args, cb, data, doneFn, method, okMethod, options, preflight, type;
      if (this.transactional) {
        this.lastChannelAccess = Date.now();
      }
      type = task.type, method = task.method, okMethod = task.okMethod, args = task.args, cb = task.cb, data = task.data, options = task.options, preflight = task.preflight;
      doneFn = function(err, res) {
        if (cb != null) {
          cb(err, res);
        }
        if (OVERFLOW_PROTECTION > 100) {
          OVERFLOW_PROTECTION = 0;
          return _.defer(done);
        } else {
          OVERFLOW_PROTECTION++;
          return done();
        }
      };
      if ((preflight != null) && !preflight()) {
        return doneFn('preflight check failed');
      }
      if (this.state === 'closed' && this.connection.state === 'open') {
        debug(1, function() {
          return "Channel reassign";
        });
        this.connection.channelManager.channelReassign(this);
        return this.open((function(_this) {
          return function(e, r) {
            return _this._taskWorker(task, done);
          };
        })(this));
      } else if (this.state !== 'open') {
        if (this.connection.state === 'destroyed') {
          return doneFn("Connection is destroyed");
        } else {
          if (this.connection.channelManager.isChannelClosed(this.channel)) {
            this.connection.channelManager.channelReassign(this);
          }
          return this.once('open', (function(_this) {
            return function() {
              return _this._taskWorker(task, done);
            };
          })(this));
        }
      } else {
        if (okMethod != null) {
          this.waitForMethod(okMethod, doneFn);
        }
        if (type === 'method') {
          this.connection._sendMethod(this.channel, method, args);
          if (okMethod == null) {
            return doneFn();
          }
        } else if (type === 'publish') {
          this.connection._sendMethod(this.channel, method, options);
          this.connection._sendBody(this.channel, data, options, function(err, res) {});
          if (okMethod == null) {
            return doneFn();
          }
        } else {
          throw new Error("a task was queue with an unknown type of " + type);
        }
      }
    };

    Channel.prototype._callOutstandingCallbacks = function(message) {
      var cb, cbs, key, outStandingCallbacks, results;
      outStandingCallbacks = this.waitingCallbacks;
      this.waitingCallbacks = {};
      if (message == null) {
        message = "Channel Unavaliable";
      }
      results = [];
      for (key in outStandingCallbacks) {
        cbs = outStandingCallbacks[key];
        results.push((function() {
          var i, len, results1;
          results1 = [];
          for (i = 0, len = cbs.length; i < len; i++) {
            cb = cbs[i];
            results1.push(typeof cb === "function" ? cb(message) : void 0);
          }
          return results1;
        })());
      }
      return results;
    };

    Channel.prototype._onChannelMethod = function(channel, method, args) {
      var closingMethod;
      if (this.transactional) {
        this.lastChannelAccess = Date.now();
      }
      if (channel !== this.channel) {
        return debug(1, function() {
          return ["channel was sent to the wrong channel object", channel, this.channel];
        });
      }
      this.callbackForMethod(method)(null, args);
      switch (method) {
        case methods.channelCloseOk:
          this.connection.channelManager.channelClosed(this.channel);
          this.state = 'closed';
          this._channelClosed("Channel closed");
          return this._callOutstandingCallbacks({
            msg: "Channel closed"
          });
        case methods.channelClose:
          this.connection.channelManager.channelClosed(channel);
          debug(1, function() {
            return "Channel closed by server " + (JSON.stringify(args));
          });
          this.state = 'closed';
          if ((args.classId != null) && (args.methodId != null)) {
            closingMethod = methodTable[args.classId][args.methodId].name;
            this.callbackForMethod(methods[closingMethod + "Ok"])(args);
          }
          this._channelClosed({
            msg: "Server closed channel",
            error: args
          });
          return this._callOutstandingCallbacks("Channel closed by server " + (JSON.stringify(args)));
        case methods.channelOpenOk:
          this.state = 'open';
          this._channelOpen();
          return this.emit('open');
        default:
          return this._onMethod(channel, method, args);
      }
    };

    Channel.prototype._connectionClosed = function() {
      if (this.state !== 'closed') {
        this.state = 'closed';
        this._channelClosed();
        if (this.channelTracker != null) {
          clearInterval(this.channelTracker);
          return this.channelTracker = null;
        }
      }
    };

    return Channel;

  })(EventEmitter);

  module.exports = Channel;

}).call(this);
